/*Возвратите отделы и среднюю зарплату для каждого отдела, где средняя зарплата для отдела меньше, 
чем средняя зарплата для всех сотрудников.
Вернуть имена, наименование отдела для сотрудников, получающих ту же зарплату, что и «Alexander»
Вывести id сотрудника, его имя, фамилию, должность, зарплата, максимальная зарплата по его должности, 
а также разница между максимальной зарплатой по его должности и зарплатой этого сотрудника, при условии,
что эта не равна разница равна нулю.
Вывести сотрудников, у которых стаж работы больше среднего стажа в их из отделе.
Все имя и фамилию менеджера в одном столбце, суммарную плату его подчиненных. Отсортировать по убыванию средней заработной платы. 
Реализовать 2 способами, один из которых с помощью коррелированного подзапроса, второй нет.
Придумать запрос с многостолбцовым подзапросом.*/
--1
SELECT d.department_name, ROUND(avg(e.salary), 2) AS avg_salary
FROM departments d LEFT JOIN employees e ON e.department_id = d.department_id
GROUP BY d.department_name
HAVING AVG(e.salary) < (SELECT AVG(salary) FROM employees)
--2
SELECT e.first_name, d.department_name
FROM departments d LEFT JOIN employees e ON e.department_id = d.department_id
WHERE e.salary IN (SELECT salary FROM employees WHERE first_name = 'Alexander')
--3
SELECT e.employee_id, e.first_name, e.last_name, j.job_title, e.salary, s.max_salary
FROM employees e LEFT JOIN jobs j ON j.job_id = e.job_id
			   LEFT JOIN (SELECT job_id, MAX(salary) AS max_salary FROM employees GROUP BY job_id) AS s 
			   ON s.job_id = e.job_id
WHERE s.max_salary - e.salary != 0
--4
SELECT e.employee_id
FROM employees e JOIN (SELECT department_id, AVG(CURRENT_DATE - HIRE_DATE) AS avg_work_record
					   FROM employees
					   GROUP BY department_id) AS avg_department ON e.department_id = avg_department.department_id
WHERE (CURRENT_DATE - e.hire_date) > avg_department.avg_work_record
--5.1 коррелированный
SELECT m.first_name || ' ' || m.last_name AS name_manager, SUM(e.salary) AS total_salary
FROM employees e JOIN employees m ON e.manager_id = m.employee_id
GROUP BY m.employee_id, m.first_name, m.last_name
HAVING 
     (SELECT AVG(e2.salary)
     FROM employees e2
     WHERE e2.manager_id  = m.employee_id) IS NOT NULL
ORDER BY 
	 (SELECT AVG(e2.salary)
     FROM employees e2
     WHERE e2.manager_id = m.employee_id) DESC
--5.2 некоррелированный
SELECT m.first_name || ' ' || m.last_name AS name_manager, e.salary_sum
FROM employees m JOIN (SELECT SUM(e.salary) AS salary_sum, AVG(e.salary) AS avg_salary, e.manager_id
        FROM employees e
        GROUP BY e.manager_id) E ON E.manager_id = m.employee_id
ORDER BY E.avg_salary DESC
--6 Найти сотрудников с максимальной зарплатой в каждом департаменте
SELECT e.first_name, e.last_name, e.department_id, e.salary
FROM employees e
WHERE (e.department_id, e.salary) IN (SELECT department_id, MAX(salary)
    								  FROM employees
    								  WHERE department_id IS NOT NULL
    								  GROUP BY department_id)
ORDER BY e.department_id;
--выберите все отделы у которых ср зарплата больше средней зп по Америке и вывести всех сотрудников через запятую в одном поле
SELECT d2.department_name, ROUND(AVG(e2.salary)) AS avg_salary, STRING_AGG(last_name || ' ' || first_name, ', ') AS employee_names
FROM departments d2 JOIN employees e2 ON d2.department_id = e2.department_id
GROUP BY d2.department_id, d2.department_name
HAVING AVG(e2.salary) > (/*ср зп по Америке*/SELECT AVG(e.salary)
    					 FROM employees e JOIN departments d ON e.department_id = d.department_id
    									  JOIN locations l ON d.location_id = l.location_id
    									  JOIN countries c ON l.country_id = c.country_id
    					 WHERE c.region_id = 2)
						 

SELECT department_name, ROUND(AVG(salary)) AS avg_salary, STRING_AGG(last_name || ' ' || first_name, ', ') AS employee_names
FROM departments d JOIN employees e ON d.department_id = e.department_id
WHERE d.department_id IN /*отделы с ср зп > ср зп Америка*/(SELECT d2.department_id
						FROM departments d2 JOIN employees e2 ON d2.department_id = e2.department_id
    				    					JOIN locations l2 ON d2.location_id = l2.location_id
                        					JOIN countries c2 ON l2.country_id = c2.country_id
						GROUP BY d2.department_id
						HAVING AVG(e2.salary) > /*ср зп по Америке*/(SELECT AVG(e.salary)
												FROM employees e JOIN departments d ON e.department_id = d.department_id
				   										 		 JOIN locations l ON d.location_id = l.location_id
				 												 JOIN countries c ON l.country_id = l.country_id
												WHERE c.region_id = 2))
GROUP BY d.department_id, d.department_name 
